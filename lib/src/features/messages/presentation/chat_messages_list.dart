// ChatMessagesList widget extracted from chat_screen.dart
//
// This widget is responsible solely for rendering the list of messages
// inside a conversation, including timestamp dividers, message bubbles,
// media handling, and empty/error states.
//
// Author: Refactor generated by AI assistant

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:timeago/timeago.dart' as timeago;

import '../data/conversation_model.dart';
import '../data/message_model.dart';
import '../data/messages_notifier.dart';
import 'media_viewer_screen.dart';

/// Encapsulates the logic for rendering a scrollable list of chat messages.
class ChatMessagesList extends ConsumerWidget {
  const ChatMessagesList({
    super.key,
    required this.messagesValue,
    required this.conversation,
    required this.currentUserId,
    required this.scrollController,
  });

  /// Async messages being watched by the parent screen.
  final AsyncValue<List<MessageModel>> messagesValue;

  /// The conversation associated with these messages (used for IDs, group status, etc.)
  final ConversationModel conversation;

  /// Firebase UID for the currently logged-in user (used to style own messages).
  final String currentUserId;

  /// ScrollController provided by the parent so the parent can scroll
  /// programmatically (e.g. after sending a new message).
  final ScrollController scrollController;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return messagesValue.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, _) => _buildErrorState(context, ref, err.toString()),
      data: (messages) {
        if (messages.isEmpty) return _buildEmptyState(context);

        return ListView.builder(
          controller: scrollController,
          reverse: true,
          padding: const EdgeInsets.all(16),
          itemCount: messages.length,
          itemBuilder: (context, index) {
            final message = messages[index];
            final isMe = message.senderId == currentUserId;
            final showTimestamp = _shouldShowTimestamp(messages, index);

            return Column(
              children: [
                if (showTimestamp) _buildTimestampDivider(context, message.sentAt),
                _buildMessageBubble(context, ref, message, isMe),
              ],
            );
          },
        );
      },
    );
  }

  // ──────────────────────────────────────────────────────────────────────────
  // UI helpers
  // ──────────────────────────────────────────────────────────────────────────

  Widget _buildEmptyState(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.chat_bubble_outline,
            size: 64,
            color: colorScheme.onSurface.withValues(alpha: 153),
          ),
          const SizedBox(height: 16),
          Text(
            'No messages yet',
            style: theme.textTheme.titleLarge?.copyWith(
              color: colorScheme.onSurface.withValues(alpha: 153),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Send the first message to start the conversation!',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurface.withValues(alpha: 153),
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildErrorState(BuildContext context, WidgetRef ref, String error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.error_outline,
            size: 64,
            color: Colors.red,
          ),
          const SizedBox(height: 16),
          Text(
            'Failed to load messages',
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
              color: Colors.red,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            error,
            style: Theme.of(context).textTheme.bodyMedium,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          FilledButton(
            onPressed: () {
              // ignore: unused_result
              ref.refresh(messagesProvider(conversation.id));
            },
            child: const Text('Retry'),
          ),
        ],
      ),
    );
  }

  Widget _buildTimestampDivider(BuildContext context, DateTime timestamp) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      child: Row(
        children: [
          const Expanded(child: Divider()),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
            decoration: BoxDecoration(
              color: colorScheme.surfaceContainer,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              _formatTimestampDivider(timestamp),
              style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: colorScheme.onSurface.withValues(alpha: 178),
                  ),
            ),
          ),
          const Expanded(child: Divider()),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(
    BuildContext context,
    WidgetRef ref,
    MessageModel message,
    bool isMe,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4),
        padding: const EdgeInsets.all(12),
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.75,
        ),
        decoration: BoxDecoration(
          color: isMe ? colorScheme.primary : colorScheme.surfaceContainer,
          borderRadius: BorderRadius.only(
            topLeft: const Radius.circular(16),
            topRight: const Radius.circular(16),
            bottomLeft: isMe ? const Radius.circular(16) : const Radius.circular(4),
            bottomRight: isMe ? const Radius.circular(4) : const Radius.circular(16),
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (conversation.isGroup)
              Padding(
                padding: const EdgeInsets.only(bottom: 4),
                child: Text(
                  message.senderUsername,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                    color: isMe ? colorScheme.onPrimary : colorScheme.primary,
                  ),
                ),
              ),
            _buildMessageContent(context, ref, message, isMe),
            const SizedBox(height: 4),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  timeago.format(message.sentAt, locale: 'en_short'),
                  style: TextStyle(
                    fontSize: 10,
                    color: isMe
                        ? colorScheme.onPrimary.withValues(alpha: 178)
                        : colorScheme.onSurface.withValues(alpha: 153),
                  ),
                ),
                if (isMe) ...[
                  const SizedBox(width: 4),
                  Icon(
                    message.hasBeenViewedBy(
                            conversation.getOtherParticipantId(message.senderId) ?? '')
                        ? Icons.done_all
                        : Icons.done,
                    size: 12,
                    color: message.hasBeenViewedBy(
                            conversation.getOtherParticipantId(message.senderId) ?? '')
                        ? Colors.blue
                        : colorScheme.onPrimary.withValues(alpha: 178),
                  ),
                ],
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMessageContent(
    BuildContext context,
    WidgetRef ref,
    MessageModel message,
    bool isMe,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    switch (message.type) {
      case MessageType.text:
        return Text(
          message.content ?? '',
          style: TextStyle(
            color: isMe ? colorScheme.onPrimary : colorScheme.onSurface,
          ),
        );
      case MessageType.image:
      case MessageType.video:
      case MessageType.snap:
        if (message.isExpired) {
          return Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.photo, size: 16, color: Colors.grey),
              const SizedBox(width: 4),
              const Text(
                'Viewed',
                style: TextStyle(
                  color: Colors.grey,
                  fontStyle: FontStyle.italic,
                  fontSize: 12,
                ),
              ),
            ],
          );
        }
        return _buildMediaMessage(context, ref, message, isMe);
      // ignore: unreachable_switch_default
      default:
        return Text(
          'Unsupported message type',
          style: TextStyle(
            fontStyle: FontStyle.italic,
            color: isMe
                ? colorScheme.onPrimary.withValues(alpha: 178)
                : colorScheme.onSurface.withValues(alpha: 153),
          ),
        );
    }
  }

  Widget _buildMediaMessage(
    BuildContext context,
    WidgetRef ref,
    MessageModel message,
    bool isMe,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    Widget snapPlaceholder({required IconData icon, required String label}) {
      return Container(
        width: 200,
        height: 200,
        decoration: BoxDecoration(
          color: Colors.black.withValues(alpha: 26),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 48, color: isMe ? colorScheme.onPrimary : colorScheme.onSurface),
            const SizedBox(height: 8),
            Text(label,
                style: TextStyle(
                    color: isMe ? colorScheme.onPrimary : colorScheme.onSurface)),
          ],
        ),
      );
    }

    // For not-yet-viewed snaps → small inline prompt
    if (message.type == MessageType.snap && !message.isExpired) {
      return GestureDetector(
        onTap: () async {
          if (message.mediaUrl == null) return;
          await Navigator.of(context).push(
            MaterialPageRoute(
              builder: (_) => MediaViewerScreen(
                mediaUrl: message.mediaUrl!,
                isSnap: true,
                duration: message.duration,
              ),
            ),
          );
          ref.read(markMessageViewedProvider(conversation.id))(message.id);
        },
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.photo,
                size: 16, color: isMe ? colorScheme.onPrimary : colorScheme.onSurface),
            const SizedBox(width: 4),
            Text(
              'View',
              style: TextStyle(
                color: isMe ? colorScheme.onPrimary : colorScheme.onSurface,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      );
    }

    if (message.mediaUrl == null) {
      // Missing media or already cleaned up
      return snapPlaceholder(icon: Icons.broken_image, label: 'Unavailable');
    }

    return GestureDetector(
      onTap: () async {
        await Navigator.of(context).push(
          MaterialPageRoute(
            builder: (_) => MediaViewerScreen(
              mediaUrl: message.mediaUrl!,
              isSnap: message.type == MessageType.snap,
              duration: message.duration,
            ),
          ),
        );
        ref.read(markMessageViewedProvider(conversation.id))(message.id);
      },
      child: ClipRRect(
        borderRadius: BorderRadius.circular(8),
        child: Image.network(
          message.mediaUrl!,
          fit: BoxFit.cover,
          width: 200,
          height: 200,
          loadingBuilder: (context, child, progress) {
            if (progress == null) return child;
            return Container(
              width: 200,
              height: 200,
              alignment: Alignment.center,
              color: Colors.black.withValues(alpha: 26),
              child: CircularProgressIndicator(
                value: progress.expectedTotalBytes != null
                    ? progress.cumulativeBytesLoaded / progress.expectedTotalBytes!
                    : null,
              ),
            );
          },
        ),
      ),
    );
  }

  // ──────────────────────────────────────────────────────────────────────────
  // Time & helper utilities
  // ──────────────────────────────────────────────────────────────────────────

  bool _shouldShowTimestamp(List<MessageModel> messages, int index) {
    if (index == messages.length - 1) return true;
    final currentMessage = messages[index];
    final nextMessage = messages[index + 1];
    final timeDiff = currentMessage.sentAt.difference(nextMessage.sentAt);
    return timeDiff.inHours >= 1;
  }

  String _formatTimestampDivider(DateTime timestamp) {
    final now = DateTime.now();
    final diff = now.difference(timestamp);

    if (diff.inDays == 0) {
      return 'Today';
    } else if (diff.inDays == 1) {
      return 'Yesterday';
    } else if (diff.inDays < 7) {
      return '${diff.inDays} days ago';
    } else {
      return '${timestamp.day}/${timestamp.month}/${timestamp.year}';
    }
  }
} 